// /api/dse-hours/index.js
module.exports = async function (context, req) {
  const URL = process.env.DSE_CSV_URL; // SAS URL to the CSV in Blob
  const respond = (status, obj) => {
    context.res = { status, headers: { "Content-Type": "application/json; charset=utf-8" }, body: JSON.stringify(obj) };
  };

  if (!URL) return respond(500, { ok: false, error: "CONFIG", msg: "DSE_CSV_URL missing" });

  try {
    const r = await fetch(URL, { headers: { "Accept": "text/csv,*/*" }, cache: "no-store", redirect: "follow" });
    const text = await r.text();
    if (!r.ok) return respond(r.status, { ok: false, error: "UPSTREAM", status: r.status, preview: text.slice(0, 200) });

    // Find header line (your file starts with "Generated By/On" lines)
    const linesAll = text.split(/\r?\n/);
    const headerIndex = linesAll.findIndex(l =>
      l.trim().toLowerCase().startsWith("gateway name,module name,engine hours run,timestamp")
    );
    if (headerIndex === -1) return respond(422, { ok: false, error: "HEADER_NOT_FOUND" });

    const dataLines = linesAll.slice(headerIndex + 1).filter(l => l.trim().length > 0);

    // Robust CSV parser (handles quoted fields with commas)
    function parseCsvLine(line) {
      const out = []; let cur = ''; let inQ = false;
      for (let i = 0; i < line.length; i++) {
        const ch = line[i];
        if (ch === '"') {
          if (inQ && line[i + 1] === '"') { cur += '"'; i++; } else { inQ = !inQ; }
        } else if (ch === ',' && !inQ) {
          out.push(cur); cur = '';
        } else {
          cur += ch;
        }
      }
      out.push(cur);
      return out.map(s => s.trim());
    }

    const items = [];
    for (const raw of dataLines) {
      const cols = parseCsvLine(raw);
      if (cols.length < 4) continue;
      const [gateway, moduleName, hours, ts] = cols.map(s => s.replace(/^"|"$/g, ""));
      if (!moduleName) continue;
      items.push({ gateway, moduleName, hours, ts });
    }

    return respond(200, { ok: true, count: items.length, items });
  } catch (e) {
    return respond(500, { ok: false, error: "PARSE", msg: String(e).slice(0, 200) });
  }
};
